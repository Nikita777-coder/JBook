# Поиск двух чисел из отсортированного массива, в сумме дающих заданное число

Задача с [LeetCode](https://leetcode.com/problems/two-sum/description/).

## Условие

Нам дан массив чисел и некоторое число `K`.
Необходимо найти положения таких двух чисел из массива, которые в сумме дают число `K`.

Каждый ввод содержит только одну возможную пару искомых чисел.

Использовать дважды одно и то же число нельзя!

### Примеры

```java
[2, 7, 11, 15], K = 0

Ответ: [0, 1]
```

```java
[3, 2, 4], K = 6

Ответ: [1, 2]
```

```java
[3, 3], K = 6

Ответ: [0, 1]
```

## Решение

Задача очень похожа на [сумму двух чисел](./two_sum.md)

### Решение перебором

Решение в лоб, простым перебором пар.

Будем суммировать пары чисел по порядку до первой пары, которая выполняет условие задачи.

```java
    public static int[] allPairsEnumeration(int[] arr, int k) {
        for (int i = 0; i < arr.length - 1; i++) {
            var item = arr[i];

            for (int j = i + 1; j < arr.length; j++) {
                var item2 = arr[j];

                if (item + item2 == k) {
                    return new int[] {i, j};
                }
            }
        }

        throw new RuntimeException();
    }
```

Время работы: O(N^2)

Память: O(1)

### Решение через HashMap

Предыдущее решение было O(N^2), поэтому попробуем улучшить наш алгоритм.

Объявим кеш из которого мы сможем достать за O(1) необходимый нам элемент и при этом сохранить положение (индекс) в массиве. Для данной задачи отлично подойдет `HashMap`.

Заметим, что мы можем оперировать нашим искомым числом `k`.
Возьмем первое число в массиве и вычтем из него `k`, таким образом получим то число, которое мы должны найти в пару.

Проверим, есть ли такое число у нас в map (проверка у нас за O(1) в данном случае). Если такого числа нет, то поместим текущее число в `HashMap` как ключ и его индекс в массиве как значение.
Теперь, если это число сможет стать парой для другого мы сможем быстро найти его в map, а не перебирать весь массив снова.

Например, у нас есть массив [2, 3, 5] и ищем мы 7.

Создаем map (пока пустую).

Берем 2 и вычитаем из искомого это число, получаем 5-ку. Ищем 5-ку в map.
Пока в map у нас нет элементов и 5-ку мы не находим. Кладем 2-ку как ключ и 0 (это же нулевой элемент в массиве) как значение, чтобы при необходимости достать ее за O(1).

Берем 3-ку и ищем в map для нее 4-ку, как подходящую пару. Не находим, поэтому кладем в кеш 3-ку и ее индекс - это 1.

Берем 5-ку и ищем в map 2-ку, успешно ее находим (она у нас с первой итерации в map) и возвращаем индекс 5-ки (это 2), а также индекс 2-ки - это значение 0.

```java
    public static int[] withSet(int[] arr, int k) {
        var cache = new HashMap<Integer, Integer>();

        for (int i = 0; i < arr.length; i++) {
            var num = k - arr[i];
            var indexSecondElement = cache.get(num);

            if (indexSecondElement != null) {
                return new int[]{i, indexSecondElement};
            } 
            
            cache.add(arr[i], i);
        }

        throw new RuntimeException();
    }
```

Время работы: O(N)

Память: O(N)
