# Середина односвязного списка

Задача с [LeetCode](https://leetcode.com/problems/middle-of-the-linked-list/description/).

## Условие

Пусть определен односвязный список:

```java
public class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

Напишите метод, который найдет срединный элемент односвязного списка, при этом итерироваться по списку можно только 1 раз.
На вход методу подается первый элемент списка (голова).

Срединным считается элемент с индексом `N / 2` (индекс считается с 0), где `N` - длина списка.
Это уточнение однозначно определит, какой элемент считается срединным, если в списке чётное количество элементов.

### Примеры

```text
Входной список: 1 -> 7 -> 3 -> 2 -> 5
Ожидаемый ответ: 3
```

```text
Входной список: 4 -> 5 -> 6 -> 7
Ожидаемый ответ: 6
```

```text
Входной список: null
Ожидаемый ответ: null
```

## Решение

### В лоб

Самое простое решение здесь - это воспользоваться структурой, позволяющей обратиться к середине списка. Например, к любой реализации `java.util.List`:

```java
    public static ListNode middleNode(ListNode head) {
        List<ListNode> lst = new ArrayList<>();

        while (head != null) {
            lst.add(head);
            head = head.next;
        }

        return lst.get(lst.size() / 2);
    }
```

#### Асимптотика решения

Время: O(N), где N - это количество элементов в связном списке

Память: O(N)

### Подсчет середины

Второй вариант решения - это просто посчитать длину списка и вторым проходом дойти ровно до нужного, серединного элемента:

```java
    public static ListNode middleNode(ListNode head) {
        int length = 0;

        ListNode curr = head;
        while (curr != null) {
            length++;
            curr = curr.next;
        }

        int i = 0;
        while(i < length / 2) {
            head = head.next;
            i++;
        }

        return head;
    }
```

#### Асимптотика решения

Время: O(N), где N - это количество элементов в связном списке

Память: O(1)

### Флаг для середины

В любой алгоритмической задаче на связные списки нужно как-то корректно перемещаться по списку, запоминать указатели на "важные" элементы, правильно переприсваивать их и учитывать то, что список обычно не бесконечный.

Заведем две ссылки, первая из них, `curr`, будет отвечать за текущую `ListNode`, а вторая, `mid`, за тот самый искомый серединный элемент.

В самом начале обе ссылки указывают на первый элемент, на голову.

После первой итерации `curr` будет указывать на второй элемент, срединным в таком случае пока остается первый. После второй итерации `curr` указывает на третий элемент и срединный уже тоже надо сдвинуть. Таким образом, если пройти весь список, можно заметить, что `mid` должен как бы 'отставать' от `curr` и сдвигаться только на 'четный' ход. То есть указатель на середину списка должен сдвигаться на каждой второй итерации, в то время как указатель на текущий элемент очевидно сдвигается на каждой итерации.

Для этого можно завести булевый флаг (`isMoveMid`), который обозначает, нужно ли в текущей итерации по списку сдвигать указатель на срединный элемент.

Чтобы добиться сдвига списка только на каждой второй итерации, значение булевого флага мы будем менять на противоположное в конце абсолютно каждой итерации. Текущий указатель мы будем сдвигать тоже на каждой итерации, а вот указатель на текущую середину - только когда значение флага = true.

Первоначальное значение флага - false, так как после первой итерации указатель на срединный элемент сдвинуться не должен.

Реализация:

```java
public static ListNode middleNode(ListNode head) {
    ListNode curr = head;
    ListNode mid = head;
    boolean isMoveMid = false;

    while (curr != null) {
        curr = curr.next;

        if (isMoveMid) {
            mid = mid.next;
        }

        isMoveMid = !isMoveMid;
    }

    return mid;
}
```

#### Асимптотика решения

Время: O(N), где N - это количество элементов в связном списке

Память: O(1)

### Два указателя

Ну и эталонным решением задачи будет использование двух указателей.

Это решение похоже на предыдущее, но вместо флага заведем просто два указателя, 'быстрый' и 'медленный'. Тот, который 'медленный' будет идти с шагом 1, а 'быстрый' с шагом 2. Таким образом, когда 'быстрый' достигнет конца списка, наш 'медленный' указатель будет указывать именно на сереидну списка:

```java
    public static ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        return slow;
    }
```

#### Асимптотика решения

Время: O(N), где N - это количество элементов в связном списке

Память: O(1)
