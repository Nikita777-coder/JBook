# Ключевое слово `static` в Java

- [Ключевое слово `static` в Java](#ключевое-слово-static-в-java)
    - [Введение](#введение)
    - [Где используется `static`](#где-используется-static)
        - [Статические методы](#статические-методы)
            - [Класс утилит](#класс-утилит)
            - [Создание объектов](#создание-объектов)
        - [Cтатические поля](#cтатические-поля)
        - [Статические блоки кода](#статические-блоки-кода)
        - [Статические вложенные классы](#статические-вложенные-классы)
    - [Вызов статических полей и методов](#вызов-статических-полей-и-методов)
    - [Доступность non-static членов в static](#доступность-non-static-членов-в-static)
    - [Hiding](#hiding)
    - [Сериализация](#сериализация)
    - [Работа с константами](#работа-с-константами)
    - [Проблемы](#проблемы)
    - [Заключение](#заключение)

## Введение

В `Java` мы оперируем такими понятиями, как классы и объекты.

Можно сказать, что класс - это как техническое описание (шаблон) прибора, купленного вами в электронном дискаунтере.
То, каким он должен быть: материал, форма, список составляющих и т.д.

В свою очередь, объект - это сам прибор со своим уникальным набором свойств.

Например, у него может быть цвет, материал изготовления, форма, он может состоять также из более мелких узлов(вспомогательных приборов) и т.д.

Все это является свойствами объекта, они уникальны для каждого прибора.

Работая с объектом мы используем эти свойства, изменяем их и реагируем на поведение объекта.

Для примера можно взять обычный массив. Массив умеет добавлять элементы, удалять и т.д. Это его поведение.
В то же время, у массива есть еще и длина - это уже свойство объекта. Добавляя или удаляя элементы вы изменяете и длину массива, т.е. поведение может влиять на свойства.

При этом, все эти изменения затрагивают **только** тот массив, с которым мы работаем сейчас и никак не влияют на другие:

```java
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {1, 2, 3};

        arr1[0] = 500;

        System.out.println(Arrays.toString(arr1));
        System.out.println(Arrays.toString(arr2));
    }
```

Массив arr1 был изменен, но это не повлияло на arr2, так как это разные объекты.

Пока мы работаем только с объектами и их методами. Т.е. для вызова метода нам нужен объект.

Однако, возникают ситуации, когда для работы с полем или методом объект не нужен.

В качестве примера рассмотрим метод, который печатает в консоль переданное через аргумент число:

```java
public class Printer {
    public void print(int n) {
        System.out.println(n);
    }
}

// Использование
new Printer().print(10);
```

Если мы напишем такой код, то для каждого использования этого метода будет необходим объект класса `Printer`.

При этом, все необходимое для работы метода передается в аргументах, т.е. **контекст** выполняемой операции полностью доступен из аргументов метода, а результат не влияет и не меняет состояние объекта, на котором метод вызывается.

Т.е. такой метод не связан с **объектом** класса, он связан только с классом в котором объявлен.

А раз он не связан с объектом, то и объект, для использования этого метода, не нужен.
Нужен только класс, в котором объявлен этот метод.

Для таких ситуацией в `Java` существует модификатор `static`.

Указав `static` у поля или метода класса, вы тем самым говорите: это поле или метод принадлежат именно классу.

Перепишем пример выше с учетом модификатора `static`:

```java
public class Printer {
    public static void print(int n) {
        System.out.println(n);
    }
}

// Использование
Printer.print(10);
```

Теперь давайте ответим на вопрос: "А где вообще можно использовать `static`?"

## Где используется `static`

Ключевое слово `static` может быть использовано при объявлении:

* Метода
* Поля
* Блока кода
* Вложенного класса

Наиболее часто встречаемое применение - это первые два пункта: поля и методы. С них и начнем наше знакомство.

### Статические методы

Статические методы принадлежат классу, а значит, для их использования не нужно создавать экземпляр объекта класса.

Чаще всего стоит задуматься о том, чтобы сделать метод статическим только в том случае, если весь контекст для его работы передается в аргументах.

Пример:

```java
public static int abs(int a) {
    return (a < 0) ? -a : a;
}
```

Для того, чтобы взять число по модулю вам не нужно ничего, кроме самого числа.
То же самое с возведением в степень или извлечением корня из числа.

Контекст операции в данном случае - это само число.
Поэтому все, что нам нужно для работы уже доступно и мы никак не влияем на состояние объекта.

Если же для работы статического метода передаваемых ему аргументов недостаточно, то это верный признак того, что стоит крепко задуматься: "А должен ли он вообще быть статическим?". Скорее всего нет.

#### Класс утилит

Очень часто статические методы, принадлежащие к одной предметной области, группируются в один класс, образуя так называемые `Utility`-классы.

Это классы без состояния(`stateless`), имеющие только статические методы и относящиеся только к одной области применения.

Такие классы часто имеют в своем названии приставки типа `Utils`, тем самым намекая на то, что это класс для утилит.

Хороший пример такого класса: `FileUtils`, который есть в большом количестве библиотек, например, `Apache Commons IO`.

Область ответственности такого класса - это работа с файлами: запись, чтение, проверка на существоание файла. Если заглянуть внутрь мы обнаружим методы `boolean exists(File file)`, `void writeToFile(List<String> data)` и т.д.

Однако не всегда такие классы называются подобным образом. Пример: `java.lang.Math`.

Такие классы всегда должны быть финальными и иметь закрытый конструктор, чтобы не дать возможности наследования и создания экземпляров:

```java
public final class Math {

    /**
     * Don't let anyone instantiate this class.
     */
    private Math() {}

    // ...
}
```

Подробнее про [final](./final.md)

#### Создание объектов

Статические методы также используют для создания экземпляров объектов, когда необходимо учесть зависимости от каких-то условий, добавления промежуточной логики в создание объекта и т.д.

Например:

```java
String num = String.valueOf(15);
```

Иногда внутри таких методов добавляется еще какая-то логика или оптимизация.

В частности, статические методы создания `valueOf()` у классов-оболочек примитивов, кроме чисел с плавающей точкой, имеют кеш.
По умолчанию данный кеш содержит значения от `-128` до `127`, если значение попадает в кеш, то оно достается оттуда, не создавая лишний объект.

```java
    public static void main(String[] args) {

        Integer a = new Integer(1);
        Integer b = new Integer(1);

        System.out.println("a == b ? " + (a == b));

        Integer c = Integer.valueOf(1);
        Integer d = Integer.valueOf(1);

        System.out.println("c == d ? " + (c == d));
    }
```

Вывод:

```java
a == b ? false
c == d ? true
```

Наиболее часто используемые значения также могут попадать в кеш.

Поэтому, обычно рекомендация простая - это стараться создавать объекты через подобные методы, если они есть у класса.

Например, использование `Integer.valueOf("14")`, вместо `new Integer(14)` описано в `JavaDoc` к конструктору `java.lang.Integer`, а сам конструктор помечен как `Deprecated`:

```java
    /**
     * Constructs a newly allocated {@code Integer} object that
     * represents the specified {@code int} value.
     *
     * @param   value   the value to be represented by the
     *                  {@code Integer} object.
     *
     * @deprecated
     * It is rarely appropriate to use this constructor. The static factory
     * {@link #valueOf(int)} is generally a better choice, as it is
     * likely to yield significantly better space and time performance.
     */
    @Deprecated(since="9", forRemoval = true)
    public Integer(int value) {
        this.value = value;
    }
```

Статические методы встречаются также и в реализациях паттернов, например [Builder](../../patterns/programming/creational/builder.md).

### Cтатические поля

Так как статическое поле принадлежит классу, то оно не является уникальным для каждого экземпляра (объекта) - оно общее для всех экземпляров.

Представим для примера, что мы хотим посчитать количество созданных экземпляров класса:

```java
class Person {
  private static int count = 0;

  Person() {
    count++;
  }

  public static int getCount() {
    return count;
  }
}

//some code
public static void main(String[] args) {
    new Person();
    new Person();
    new Person();
    new Person();

    System.out.println(Person.getCount());
}
```

Выполнение кода даст нам результат `4`.

В основном статические поля используются для создания констант:

```java
final class FileUtils {
  public static final char SEPARATOR = ';';
  public static final int BATCH_SIZE = '1024';
}
```

Тут, я думаю, все понятно - константа и в Африке константа.

Также статическое поле используется при реализации паттерна [Singleton](../../patterns/programming/creational/singleton.md).

### Статические блоки кода

Инициализация статического блока кода выполняется на этапе загрузки класса, грубо говоря, в момент первого к нему обращения.
Благодаря этому статические блоки кода используются тогда, когда необходимо выполнить какую-то логику еще **до** вызова конструктора.

С небольшой оговоркой можно считать, что это конструктор для класса (не объекта).

Выглядит синтаксис статического блока так:

```java
static {
    // Static block code
}
```

Статических блоков может быть несколько, их выполнение будет происходить в порядке объявления.

Пример:

```java
public class Car {
    static Map<String, Set<Car>> catalog = new HashMap<String, Set<Car>>();
    static {
        catalog.put("model105", new HashSet<Car>());
        catalog.put("model125", new HashSet<Car>());
        catalog.put("model140", new HashSet<Car>());
        catalog.put("model201", new HashSet<Car>());
    }

    public Car (String model) {
        catalog.get(model).add(this);
        // ...
    }
    // ...
}
```

Статические блоки кода применяются еще и при работе, например, с [JDBC](https://ru.wikipedia.org/wiki/Java_Database_Connectivity), когда надо загрузить драйвер для работы с конкретной БД (загрузку драйвера как раз раньше делали в статическом блоке):

```java
/**
 * Load the initial JDBC drivers by checking the System property
 * jdbc.properties and then use the {@code ServiceLoader} mechanism
 */
static {
    loadInitialDrivers();
    println("JDBC DriverManager initialized");
}
```

Подробнее о порядке выполнения кода при инициализации класса: [Порядок инициализации полей класса в Java](./order_of_loading.md).

Однако надо помнить, что в случае возникновения исключения в статическом блоке кода выбросится `ExceptionInInitializerError`:

```java
public class Main {
    static {
        System.out.println(1/ 0);
    }
    
    public static void main(String[] args) {
    }
}
```

Запуск кода даст:

```java
Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: java.lang.ArithmeticException: / by zero
    at Main.<clinit>(Main.java:5)
```

### Статические вложенные классы

В `Java` можно объявить класс внутри другого класса.

Такой вложенный класс называется `nested`-классом.
Вложенные классы делятся на статические и нестатические.

Нестатические вложенные классы называют еще внутренними классами или `inner`-классами.
Класс, внутри которого объявлен другой класс, назовем обрамляющим или `outer`-классом.

Для иллюстрации вышесказанного:

```java
public class OuterClass {
  static class NestedClass {

  }

  class InnerClass {

  }
}
```

Понятно, что `nested` класссы принадлежат `outer` классу, в то время как `inner` классы принадлежат уже экземпляру объекта `outer` класса:

```java
public class Main {
    public static void main(String[] args) {
        OuterClass.NestedClass nestedClass = new OuterClass.NestedClass();
        OuterClass.InnerClass innerClass = new OuterClass().new InnerClass();
    }
}

class OuterClass {
    static class NestedClass {

    }

    class InnerClass {

    }
}
```

Зачем же вообще нужны `nested` классы?

Например, вы пишите реализацию связного списка и вам нужен класс `Node`, в котором вы будете хранить значение и ссылки на предыдущий и следующий элемент списка.
Этот класс будет использоваться **только** внутри вашей реализации и нигде больше не нужен.

Логично, что исходя из таких вводных, делать отдельный `public` класс кажется достаточно избыточным действием. В таком случае можно объявить `nested` класс и работать с ним.

Если посмотреть стандартную реализацию `java.util.LinkedHashMap` в `Java 8`, то там именно так и сделано:

```java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>
{

    /**
     * HashMap.Node subclass for normal LinkedHashMap entries.
     */
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }

    // some code and implementation.
}
```

Объявив вложенный класс, вы добиваетесь сразу нескольких преимуществ:

* Логически сгруппируете классы, которые используются, в одном месте

  Если класс полезен только для одного стороннего класса, то логично ввести его в этот класс и поддерживать вместе.

* Это способ привести код к более читабельному и поддерживаемому виду

  Достигается это тем, что вы можете объявить вложенный класс ближе к месту использования и скрыть его от использования в других классах.

* Это улучшает инкапсуляцию

  Если вложенный класс используется **только** внутри стороннего класса, логично скрыть его и использовать лишь внутри. Аналогично с тем, как мы объявляем `private` поля.

Статическим может быть только вложенный класс, но не класс верхнего уровня.

```java
// ошибка компиляции
public static class Main {
    public static void main(String[] args) {
        // ...
    }
}
```

Подробнее о вложенных классах: [Вложенные классы в Java](./inner-classes-java.md).

## Вызов статических полей и методов

Если коротко, то раз поле или метод принадлежит классу, то и обращаться к нему необходимо через имя класса.

Давайте посмотрим на следующий класс, содержащий статическое поле:

```java
public class Example {
    public static int field = 14;
}
```

Мы хотим обратиться к этому полю, и возникает вопрос: как правильно это сделать?

Есть два рабочих варианта:

* Обратиться к полю через экземпляр объекта класса

    ```java
    public class ExampleTest {
        public static void main(String[] args) {
            System.out.println(new Example().field);
        }
    }
    ```

* Обратиться к полю через класс

    ```java
    public class ExampleTest {
        public static void main(String[] args) {
            System.out.println(Example.field);
        }
    }
    ```

Несмотря на то, что оба способа рабочие, важно отметить, что про первый нужно забыть.

Так как статические поля принадлежат не экземпляру объекта класса, а самому классу, поэтому сам объект для доступа к полю или методу не нужен. Более того, сам объект не будет даже использоваться для вызова!

Для демонстрации рассмотрим следующий пример:

```java
Example ex = null;
System.out.println(ex.field);
```

Что будет результатом выполнения этого кода?

Если вы ответили, что будет исключение `NullPointerException`, то вы ошиблись и не усвоили главную мысль этого текста.

Мы не увидим `NullPointerException`, так как вместо `ex` в месте обращения к статической переменной `field` умный компилятор подставит `Example` - имя класса:

```java
System.out.println(Example.field);
```

Что корректно и без ошибок выведет нам `14`.

Т.е даже если вы будете обращаться к статическому полю или методу через объекты экземпляров, то компилятор все равно будет вас исправлять.

Запомните: обращение к статическим методам и полям осуществляется **только** через имя класса.

## Доступность non-static членов в static

Из того, что `static`-члены принадлежат именно **классу** следует еще и то, что из статических методов нельзя получить доступ к нестатическим членам класса, т.е к тому, что принадлежит объекту.

```java
public class Counter {

private int count;

public static void printCount() {
   System.out.println(count); //compile time error
 }
}
```

Это довольно логично, так как экземпляра объекта класса может еще не быть, поэтому доступа до переменной `count` нет.

## Hiding

Еще один интересный момент состоит в том, что статический метод нельзя переопределить, т.е. `override` метода невозможен.

Однако объявить один и тот же метод в классе-наследнике и в родительском классе можно:

```java
public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        Child ch = new Child();

        p.test(1);
        ch.test(2);
    }

    static class Parent {
        public static void test(int k) {
            System.out.println("Static Parent " + k);
        }
    }

    static class Child extends Parent {
        public static void test(int k) {
            System.out.println("Static Child " + k);
        }
    }
}
```

Запустим код и получим:

```java
Static Parent 1
Static Child 2
```

Т.е. не получилось переопределить метод, но его как бы 'скрыли'. Такое скрытие называется `hiding`.

При обращении к статическому методу, который объявлен как в родительском, так и в классе-наследнике, во время компиляции всегда будет вызван метод исходя из **типа** ссылки, по которой идет обращение к такому полю или методу.

В первом вызове тип ссылки `p` был `Parent`, во втором - `Child`.
Соответственно, в первом случае метод `test` вызвался у класса `Parent`, а во втором у `Child`.

Т.е. он не будет участвовать в полиморфизме - если ваш метод принимает параметр `Parent p` и вызывает на полученном объекте статичный метод `p.test()`, то всегда будет вызван именно метод класса `Parent`, даже если передан был объект класса `Child` или другого потомка. Именно поэтому возможность вызова статичных методов на экземплярах считается вредоносной и повсеместно осуждается на практике.

Данный пример непрозрачно намекает, что использовать статические методы при наследовании **не стоит**.

Поэтому, если вы не хотите потерять друзей, сон и семью - избегайте подобного.

## Сериализация

Во время бинарной `Java` сериализации, также как и `transient` переменные, статические поля **не сериализуются**.

После десериализации новый объект будет содержать его первичное значение.

Подробнее в [Binary Serialization](../../serialization/binary/binary.md)

## Работа с константами

Константа - это статическое, финальное поле у класса.

```java
/**
 * Don't let anyone instantiate this class.
 */
public final class Math {

    /**
     * The {@code double} value that is closer than any other to
     * <i>e</i>, the base of the natural logarithms.
     */
    public static final double E = 2.7182818284590452354;

    /**
     * The {@code double} value that is closer than any other to
     * <i>pi</i>, the ratio of the circumference of a circle to its
     * diameter.
     */
    public static final double PI = 3.14159265358979323846;

    // ...
}
```

Объявление константы обычно происходит в классе, к которому она относится, как в примере выше. Однако существует еще один подход - это группирвока констант в вложенных классах:

```java
public class Constants {
    public static final class Category {
        private Category() {
            throw new AssertionError();
        }

        public static final int NAME_LENGTH = 100;
    }

    public static final class Country {
        private Country() {
            throw new AssertionError();
        }

        public static final int NAME_LENGTH = 100;
    }

    public static final class Series {
        private Series() {
            throw new AssertionError();
        }

        public static final int COMMENT_LENGTH = 255;
    }

    public static final class User {
        private User() {
            throw new AssertionError();
        }

        public static final int LOGIN_LENGTH = 25;
        public static final int NAME_LENGTH = 100;
    }
}
```

Теперь вы можете обращаться к константе как:

```java
Constants.User.NAME_LENGTH
```

В большинстве случаев это излишне, так как понятнее для разработчика объявлять константу в классе, где она будет использоваться, но тем не менее, знать о еще одной возможности надо.

## Проблемы

Вообще говоря, `static` поля и методы плохо вписываются в `ООП` парадигму, поэтому в идеале лучше стараться свести использование `static` к минимуму.

Почему?

Во-первых: статические поля нарушают принцип инкапсуляции.

Статические переменные представляют глобальное состояние. С глобальным состоянием трудно работать, сложно держать его контекст в голове и его трудно тестировать: если мы создаем новый экземпляр объекта, то можем рассуждать о его новом (изолированном) состоянии в тестах и логике. Если же работа идет с кодом, который использует статические переменные, то этот код (и переменная) может находиться в любом состоянии и что угодно может его изменить (в рамках области доступности).

Во-вторых: если относится к методам как к поведению, то статические методы нарушают эту концепцию:

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        Employee e = new Employee();

        printGreeting(p);
        printGreeting(e);
    }

    public static void printGreeting(Person p) {
        p.greeting();
    }
}

class Person {
    public static void greeting() {
        System.out.println("Person greeting");
    }
}

class Employee extends Person {
    public static void greeting() {
        System.out.println("Employee greeting");
    }
}
```

Поэтому относится к статическому методу надо как к процедуре и не более.

Вдобавок к этому, работа со статическими методами и полями не потокобезопасна.

## Заключение

Ключевое слово `static` может быть использовано при объявлении:

* Поля класса
* Метода класса
* Блока кода
* Вложенного класса

Чаще всего оно применяется для первых двух случаев.

Модификатор `static` применяется тогда, когда необходимо сделать так, чтобы поле, метод и т.д. принадлежали классу.
Статические члены класса напрямую принадлежат классу, а не его экземпляру.

Для ответа на вопрос, должен ли быть метод статическим, надо понять: доступен ли **контекст** выполняемой операции полностью из аргументов метода?

Если ответ 'да', то это весомый аргумент для использования `static`. Так как в таком случае, вам не нужен объект класса - вы не используете его состояние, поведение и т.д.

Использовать статические методы при наследовании **не стоит** из-за `hiding`.

Из того, что `static`-члены принадлежат именно **классу** следует еще и то, что из статических методов нельзя получить доступ к нестатическим членам класса, т.е к тому, что принадлежит объекту.

В целом, `static` использовать стоит аккуратно, помимо случаев, когда вы создаете константу или factory-`метод`.
