# java.lang.Object и все-все-все

## Введение

`Java` - это объектно-ориентированный язык программирования, где в основном оперируют понятиями класса и объекта.

Подробнее про ООП можно прочесть [здесь](../oop/intro.md).

Классы выстраивают некую иерархию и главный класс в `Java` - это `java.lang.Object`, вершина иерархии всех классов в `Java`.

Это значит, что каждый класс, **включая массивы**, является потомком `java.lang.Object`.

Именно поэтому явное наследование от него не имеет смысла:

```java
public class Test extends Object {
    // some code
}
```

При этом, даже если вы не создали ни одного конструктора для вашего класса, то `Java` создаст конструктор по умолчанию.
И, с учетом того, что у нас есть родительский класс, этот конструктор будет выглядеть в виде:

```java
public class Test {
    public Test() {
        super();
    }
}
```

Теперь давайте посмотрим какое влияние на поведение (методы, которые он предоставляет) классов оказывает `java.lang.Object`, являясь родительским классом.

## Методы java.lang.Object

На момент `Java 21`, всего в `java.lang.Object` представлено 11 `public`-методов, 6 из которых имеют нативную реализацию. Так как все классы в `Java` являются потомками `java.lang.Object`, то все эти методы унаследованы каждым классом в `Java`. Именно поэтому важно представлять о чем они и какие возможности предоставляют.

Нативная реализация означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
А значит, эта реализация зависит от `JVM`.

Возможно, вас сейчас это напугало, но на самом деле достаточно просто понимать, что `native` означает лишь то, что мы вызываем код, который реализован не на `Java`.

Вот эти 11 методов:

* [toString](to_string.md)
* [clone](clone.md)
* [hashCode](hashcode.md)
* [equals](equals.md)
* [finalize](finalize.md)
* [getClass](get_class.md)
* `wait(long timeoutMillis)`
* `wait()`
* `wait(long timeoutMillis, int nanos)`
* `notify()`
* `notifyAll()`

## Почему java.lang.Object не является абстрактным классом

Глядя на объявление класса `java.lang.Object` может возникнуть вопрос: а почему это не абстрактный класс?

Про абстрактные классы прочитать можно [тут](../oop/abstract_class.md).

В целом, на первый взгляд было бы логично ожидать, что такой класс должен быть абстрактным.
Это кажется следует даже из названия класса: `Object`, которое является довольно обобщенным - "объект".

Однако, модификатора `abstract` у `java.lang.Object` нет и мы постараемся ответить на вопрос: почему?

**ДИСКЛЕЙМЕР**: Все нижесказанное - это мое личное мнение.

Для ответа на этот вопрос давайте разберемся, а какие плюсы принес бы модификатор `asbtract`?

### Абстрактный java.lang.Object с абстрактными методами

Представим себе ситуацию, когда у `java.lang.Object` существует один или несколько абстрактных методов.
Что это дает?

Пометив какие-то методы `abstract` мы явно потребуем от разработчиков реализации этих методов.

Еще раз взглянем на методы класса `java.lang.Object` и подумаем: насколько упростит жизнь разработчика, то, что хотя бы один из методов будет необходимо реализовывать каждый раз при объявлении своих классов?

Методы `wait`, `notify`, `finalize`, `notifyAll` и `getClass` довольно сложны (часть из этих методов являются `native`-методами) и требовать каждый раз от разработчика их реализации - это дополнительные проблемы и большое количество подводных камней, на которые все будут регулярно натыкаться. Это не имеет смысла и практической пользы.

Методы `equals`, `hashCode`, `clone` и `toString` с одной стороны можно было бы сделать абстрактными, явно требуя от программистов их переопределения.

Но объявлять эти методы абстрактными - это все-таки снова делать шаг в сторону усложнения написания кода, ведь требовать от класса, которому не нужно уметь представлять себя в строковом виде определение `toString` - неразумно и глупо.
В таком случае разработчик будет каждый раз писать какой-то "фейковый" `toString`, не имеющий ценности и необходимости.

Ну и с другой стороны, кажется, что эти методы относятся к отдельным абстракциям.
Далеко не каждому классу нужно (да и можно) иметь строковое представление, возможности клонирования, сравнения и предоставления хэш-кода.

На мой взгляд, подобные методы логичнее было бы вынести в собственные интерфейсы, например, в `Hashable`, чтобы добавлением интерфейса привнести уже действительно необходимый функционал.

В итоге, делать методы класса `java.lang.Object` абстрактными - это чрезмерное усложнение, при добавлении не самых больших преимуществ.

Поэтому, на мой взгляд, оптимальное решение было то, какое выбрали в текущей реализации.

#### Абстрактный java.lang.Object без абстрактных методов

Теперь предположим, что класс `java.lang.Object` является абстрактным, но его вид такой же, как и сейчас: он не имеет абстрактных методов.

С точки зрения наименований - это было бы довольно логично, чтобы такой класс был абстрактным, ведь объект - это всегда что-то наивысше абстрактное. Объектами являются и лампа, и машина, и дом.

Поэтому, с точки зрения дизайна языка, наверное, было бы правильней чтобы `java.lang.Object` был абстрактным.

Добавив модификатор `abstract` к классу мы явно запретим возможность создания таких объектов.

Однако, возможность создания некоторого абстрактного, 'пустого' объекта может быть полезна, а вот запрет на такое действие не дает никакой выгоды, кроме стилистической, так как это больше вопрос дизайна.

Рассмотрим пользу от возможности создания экземпляра класса `java.lang.Object`.

Экземпляр класса `java.lang.Object` можно использовать для `synchronized` операций.
Так как в `Java` можно занять монитор объекта и сделать синхронизацию на нем.

И часто для таких целей пишут что-то в виде:

```java
public class Example {
    private final Object lock = new Object();

    public void doSomething() {
        synchronized (lock) {
            // do possibly dangerous stuff
        }
    }
}
```

С другой стороны, для возможности использовать `synchronized` можно было бы сделать специальный объект, например, `java.lang.Lock` или что-то подобное.

Чтобы тип поля явно говорил нам для чего это поле будет использоваться, ведь когда вы видите поле с типом `Object` - это может вводить в ступор, особенно, если название переменной непонятно.

Иногда бывает также удобно иметь возможность создать объект-пустышку, так называемый `placeholder`, без состояния, например, как это сделано в [java.util.HashSet](../collections/set/hash_set.md).
Это реализация `java.util.Map`, где ключами являются элементы множества, а значениями будут объекты-пустышки.

И опять же, для таких целей можно было бы завести специальный класс, что-то типа `java.lang.Placeholder`, являющийся наследником нашего абстрактного `java.lang.Object`.

Исходя из вышесказанного можно сделать вывод, что объекты-пустышки иногда бывают полезны и применимы в реальных задачах. И поэтому было бы полезно иметь возможность ими пользоваться, это вполне допустимо и с точки зрения дизайна языка.

Также, возможно, есть еще какие-то применения `java.lang.Object`, например в механизме `Reflection`, в безопасности и так далее.

Поэтому, я считаю, что `java.lang.Object` **может** быть не абстрактным.
И я не стал бы относить это к минусам дизайна языка.

А вот методы `equals`, `hashCode`, `clone` и `toString`, думаю, правильнее было бы поместить в отдельные интерфейсы. Так, чтобы это поведение я мог бы *подмешивать* к своим классам тогда, когда мне это было бы необходимо.

## Заключение

Каждый класс в `Java` неявно является наследником `java.lang.Object`, благодаря чему каждый класс имеет методы `equals`, `hashCode`, `toString` и т.д.

Помните, что оператор `==` сравнивает объекты по ссылкам, поэтому, если вы хотите сравнивать объекты по внутреннему состоянию, то необходимо переопределить `equals`. Вместе с `equals` обязательно переопределять еще и `hashCode`, так как эти методы тесно связаны друг с другом.

Также хорошим тоном является переопределение `toString`, так как текстовое представление объекта помогает при отладке и печати объекта в консоль или лог-файл.
Следите за тем, чтобы в `toString` не попадала конфиденциальная информация, пароли и т.д. Старайтесь не завязывать логику программы на результат работы `toString`.

Никогда не используйте `finalize`, ввиду непредсказуемости его работы, в частности момента вызова и исполнение метода.

Будьте аккуратнее с методом `clone`, так как при таком клонировании объекта встречается большое количество подводных камней, не вызывается конструктор класса и т.д. Предпочитайте конструктор копирования или статические методы-фабрики.
