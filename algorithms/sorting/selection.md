# Сортировка выбором (Selection sort)

## Введение

Алгоритм сортировки выбором является одним из самых простых алгоритмов как для понимания, так и для реализации.

## Алгоритм

На каждом i-ом шаге алгоритма находим i-ый минимальный (или максимальный, если сортировка происходит по убыванию) элемент и меняем его местами с i-ым элементом в массиве. Таким образом будет получен массив, отсортированный по неубыванию (возрастанию).

Грубо говоря, наш массив состоит из двух подмассивов (частей): отстортированная часть и неотсортированная. В начале неотсортированная часть - это и есть весь наш массив, а отсортированная часть отсутствует.

В неотсортированном подмассиве ищется локальный максимум (минимум).
Найденный максимум (минимум) меняется местами с последним (первым) элементом в подмассиве.
Если в массиве остались неотсортированные подмассивы — повторяем итерацию.

![Selection sort](../../images/algorithms/sorting/selection/selection_sort.gif)

Для простоты понимания работы представьте, что у вас есть неотсортированный список значений. Теперь найдем максимальный (или минимальный) элемент в этом списке и переместим его в новый (итоговый, отсортированный). После этого в исходном списке снова найдем максимальный элемент из оставшихся и снова переместим его в итоговый список (но на вторую позицию, ведь на первой уже расположился прошлый). И так, повторяя до тех пор, пока массив не закончится вы на выходе получите, что 'итоговый' список - это отсортированный список, а 'исходный' список пуст.

Ну а чтобы не тратить лишнюю память и не создавать 'второй' список (результирующий) - будем не 'переносить' элементы из 'старого' в 'новый', а просто менять элементы в исходном местами.

## Реализация

Создадим два цикла, первый (внешний) - это цикл для именно перемещения элементов, а второй (внутренний) для поиска наименьшего (наибольшего) элемента.

В нашей реализации мы будем сортировать по возрастанию, т.е. искать локальные минимумы.

```java
public static void selectionSort(int[] arr) {
        for (int k = 0; k < arr.length - 1; k++) {
            int minIndex = k;
            for (int i = k + 1; i < arr.length; i++) {
                if (arr[i] < arr[minIndex]) {
                    minIndex = i;
                }
            }

            // теперь minIndex - это индекс минимального элемента
            if (minIndex != k) {
                int tmp = arr[k];
                arr[k] = arr[minIndex];
                arr[minIndex] = tmp;
            }
        }
    }
```

Внешний цикл может быть с условием `arr.length - 1`, так как последнюю итерацию можно не делать: массив будет уже отсортирован.

## Производительность

В представленной реализации, из-за двух вложенных циклов временная сложность: `О(N^2)`.

Однако, сортировка выбором эффективна настолько, насколько эффективно организован поиск минимального/максимального элемента в неотсортированной части массива. При переборе (как у нас) это будет `О(N^2)`, но при более эффективных алгоритмах поиска временная сложность будет другой (зависеть от временной сложности поиска минимального/максимального элемента).

## Отличия от сортировки вставками

Несмотря на то, что сортировка выбором и [сортировка вставками](insertion.md) очень похожи (и там, и там по очереди из неотсортированной части массива извлекаются элементы и вставляются в отсортированную часть) - эти классы алгоритмов отличны.

В сортировке вставками из неотсортированной части массива извлекается любой элемент (идем по массиву просто), далее ищется его место в отсортированной части, после чего он вставляется в нужное (найденное) место. В сортировке выбором ищется максимальный (или минимальный) элемент, который дополняет отсортированную часть массива.

Грубо говоря: во вставках мы ищем куда вставить очередной элемент, а в выборе — нет, мы заранее знаем в какое место его нужно поставить (но для этого ищем нужный элемент).

## Заключение

Сортировка выбором может встречаться в работе, однако надо помнить, что ее эффективность зависит от того, насколько эффективно организован поиск минимального/максимального элемента в неотсортированной части массива.

Сортировка простым выбором представляет из себя грубый двойной перебор и работает за `O(N^2)`.

У сортировки выбором есть несколько модификаций: Cycle sort, Bingo sort, Double selection sort.

## Полезные ссылки

1. [Сортировка выбором](https://ru.algorithmica.org/cs/sorting/selection/)
2. [Habr. Сортировки выбором](https://habr.com/ru/articles/422085/) **РЕКОМЕНДУЮ**
3. [Wikipedia. Сортировка выбором](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC)
4. [Selection Sort in Java](https://www.baeldung.com/java-selection-sort)
